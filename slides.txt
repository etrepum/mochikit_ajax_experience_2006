.. include:: <s5defs.txt>

===================
 Intro to MochiKit
===================

:Author: Bob Ippolito
:Date: May 2006

.. contents::
    :class: handout


What's MochiKit?
================

* Makes JavaScript suck less
* Provides browser workarounds
* Simplifies AJAX and DOM
* Plays nicely with other code


Another library?!
=================

* Prototype was undocumented, no tests, didn't play nice
* Dojo had no documentation or demos
* Everything else was outdated, not liberally licensed,
  not cross-platform


MochiKit Design Goals
=====================

* Documentation
* DOCUMENTATION
* Test early test often
* Stay out of the way (not a framework)
* Consistent
* Portable
* Workaround browser stupidity


Why MochiKit?
=============

* Extremely well documented, tested, stable
* Safari 2.0, Firefox 1.0, IE 6, Opera 8.5 (and others)
* Abstracts async behavior
* MochiKit.DOM syntax makes DOM painless
* MochiKit.Signal works around LOTS of browser misfeatures
* Python-like (think "standard library")


Why not MochiKit?
=================

* No support for IE 5.5
* No widgets
* No animation, transitions, etc.
* ... but we're working on a Scriptaculous port (MochiKit 1.4)


MochiKit.Base
=============

* Beats some sense into JavaScript
* Provides analogs to a lot Python built-ins and object protocols
* This is the "suck less" part


toString ambiguity
==================

* Which one of these things is not like the other:

    - [1]
    - 1.0
    - "1"

* They're all the same according to JavaScript's toString!  Totally useless
  for debugging.


repr > toString
===============

* MochiKit provides repr() instead, just like Python.
  Think "programmer representation".

    - repr([1]) == "[1]"
    - repr(1.0) == "1"
    - repr("1") == "\"1\""

* repr understands primitive types, objects that implement ``repr`` or 
  ``__repr__``

* Extensible with an adapter registry


compare instead of operators
============================

* JavaScript comparisons are WHACK (these are ``true``!)

  - [1,"2"] == "1,2"
  - ([""] == "") && ([] == "") && ([] != [""])


* compare(a, b) provides consistent results

  - Usable with Array.prototype.sort
  - Understands String, Date, Array, Number, String, ...
  - Can be extended with adapter registry


JSON serialization
==================

* serializeJSON(object) -> JSON string

  - Understands primitive types
  - Will call ``json`` or ``__json__`` on objects if method exists
  - Can be extended with adapter registry


Wait.. Adapters?
================

* Not a good idea to hack on built-in objects
* MochiKit doesn't always know what you want to do
* Adapters let you extend existing functions

  - registerRepr(name, check, wrap, override=false)
  - registerComparator(name, check, wrap, override=false)
  - registerJSON(name, check, wrap, override=false)


Registering an adapter
======================

name:
    a unique identifier for your adapter (can be used to unregister)

check:
    a predicate, should wrap be called?

wrap:
    performs the operation


DOM comparator example
======================

Register HTML-based comparator for DOM nodes::

    function isDOMNode(node) {
        return typeof(node.nodeType) == "number";
    }

    function compareDOMNodes(a, b) {
        return compare(a.innerHTML, b.innerHTML);
    }

    registerComparator("compareDOM", isDOMNode, compareDOMNode);


queryString
===========

* queryString(["foo", "bar"], [1, 2]) == "foo=1&bar=2"
* queryString({foo: 1, bar: 2}) == "foo=1&bar=2"
* queryString("formNode") == "foo=1&bar=2", given::

    <form id="formNode">
        <input type="hidden" name="foo" value="1" />
        <input type="hidden" name="bar" value="2" />
    </form>


Mangling Objects
================

merge(obj[, ...]):
    Create a new object consisting of every property in the given objects
    (last object given takes precedence)

update(obj[, ...]):
    In-place version of merge

updatetree(obj[, ...]):
    Recursive version of update

setdefault(obj[, ...]):
    Like update, but does NOT overwrite existing properties


Object Introspection
====================

keys(obj):
    returns an Array of every property on obj

items(obj):
    returns an Array of every [property, value] on obj


Function functions
==================

bind(fn, self[, arg...]):
    new function, equivalent to fn.apply(self, concat(arg..., arguments))

method(self, fn[, arg...]):
    convenience form for bind

itemgetter(name):
    new function(obj), equivalent to obj[name]

keyComparator(key, ...):
    new sort function that does compare(a[key], b[key])

forwardCall(name):
    new function, forwards calls to this[name] (for delegation)


Basic Array functions
=====================

Array.prototype is missing lots of useful functions (cross-platform anyway)

concat(lst[, ...]):
    concatenates Arrays

extend(self, seq, skip=0):
    extends a list in-place

flattenArguments(args[, ...]):
    Creates a flat Array from a bunch of arguments, recursively flattening
    any Arrays that are encountered


compare-based Array functions
=============================

findValue(lst, value, start=0, end=lst.length):
    finds index of value (using compare)

findIdentical(lst, value, start=0, end=lst.length):
    finds index of value (using === for identity)

listMin(lst):
    finds least item in lst (using compare)

listMax(lst):
    finds greatest item in lst (using compare)


Higher-order Array functions
============================

filter(predicate, lst):
    new Array where predicate(lst[n]) is true

map(func, lst):
    new Array of [func(lst[0]), func(lst[1]), ...]


MochiKit.Iter
=============

MochiKit.Iter provides generalized iteration, very similar to Python's
iteration protocol and itertools module.

* Works great on Arrays, but also on anything iterable.
* Anything with a ``next`` method is iterable, and the iteration stops when
  StopIteration is thrown.
* Objects can define an ``iter`` method to return an iterable
* Can register adapters too, with registerIterable.


Collapsing Iterators
====================

exhaust(iterable):
    Iterate over ``iterable`` and throw away the results

list(iterable):
    Convert ``iterable`` to a new Array

sorted(iterable, cmp=compare):
    Return a sorted Array from ``iterable`` using ``cmp`` as the comparator

sum(iterable, start=0):
    Return the sum of each item in ``iterable`` plus the ``start``.


Iterating Iterables
===================

The hard way::

    var itr = iter(iterable);
    try {
        while (true) {
            var item = itr.next();
            // ...
        }
    } catch (e) {
        if (e != StopIteration) throw e;
    }


Sane Iterable Iteration
=======================

The easy way::

    forEach(iterable, function (item) {
        // ...
    })


Infinite Iterators
==================

count(n=0):
    Iterates over a sequence of numbers (n, n + 1, n + 2, ...)

cycle(iterable):
    Iterates over iterable and saves the results.  Once iterable is exhausted,
    it iterates over the cached result Array indefinitely.

repeat(item):
    Returns an iterator that returns item over and over, same as
    cycle([item])


Should I care about Iter?
=========================

* You don't need to understand it to understand MochiKit
* Used primarily to simplify internal code, helps a lot with DOM generation
* You might not need it, but it is convenient for people used to a more
  functional paradigm
* If you don't use itertools in Python, you probably won't directly use
  much of MochiKit.Iter either


MochiKit.DateTime
=================

* JavaScript Date objects aren't very convenient
* W3C profile ISO 8601 style timestamps are Good

ISO Dates
=========

isoDate(str):
    Convert ISO 8601 date to a Date object

toISODate(date):
    Convert a Date object to an ISO 8601 date


Silly American Dates
====================

americanDate(str):
    Convert an MM/DD/YYYY date to a Date object

toAmericanDate(date):
    Convert a Date object to a M/D/YYYY date (1/1/2001)

toPaddedAmericanDate(date):
    Convert a Date object to a MM/DM/YYYY date (01/01/2001)


Time and Timestamps
===================

isoTimestamp(str):
    Convert a YYYY-MM-DD hh:mm:ss or YYYY-MM-DDThh:mm:ssZ timestamp to a
    Date object

toISOTime(date):
    Convert a Date object to a hh:mm:ss string

toISOTimestamp(date, realISO=false):
    Convert a Date object to a YYYY-MM-DD hh:mm:ss string.  If realISO is true,
    then use the proper YYYY-MM-DDThh:mm:ssZ form.


MochiKit.Format
===============

* JavaScript doesn't really do string formatting
* Users like to see big numbers with thousands separators
* Number formatting based on Java's Number Format Pattern Syntax


Simple String Mangling
======================

strip(str, chars="\\s"):
    Return a string based on str with leading and trailing whitespace stripped.
    If the chars regex is specified, it will be used instead of the default.

lstrip(str, chars="\\s"):
    strip only leading whitespace

rstrip(str, chars="\\s"):
    strip only trailing whitespace


Number Formatting
=================

numberFormatter(pattern, placeholder="", locale="default"):
    Return a function that formats numbers using the given pattern

Examples::
    
    >>> dollarFormat = numberFormatter("$###,###.##")
    >>> dollarFormat(1234567.89)
    "$1,234,567.89"
    
    >>> percentFormat = numberFormatter("###,###%")
    >>> percentFormat(123.45)
    "12,345%"


MochiKit.Logging
================

* alert() sucks
* Debugging is hard enough
* Not every browser has FireBug
* I've had no luck with Venkman
* Less luck with Microsoft's Script Debugger


Simple logging
==============

log(msg):
    Logs a message at the INFO level

logDebug(msg):
    Logs a message at the DEBUG level

logWarning, logError, logFatal...


Where'd my log messages go?
===========================

* In Safari, Firefox with FireBug, and Opera they will be logged to the
  appropriate console (but you can turn this off).
* Will also go to any logging listener
* Logging listeners are just functions that take log message objects


Bookmarklet Debugging
=====================

Just bookmark this::

    javascript:MochiKit.Logging.logger.debuggingBookmarklet()

Currently, this is a pop-up MochiKit.LoggingPane.


MochiKit.LoggingPane
====================

* A usable MochiKit.Logging listener
* Can be used in-line or as a pop-up window
* Could be fancier, but it gets the job done


Manually creating a LoggingPane
===============================

Pop-up::

    createLoggingPane()

Inline::

    createLoggingPane(true)


MochiKit.DOM
============

* DOM is painful, but it doesn't have to be
* Functions for finding, creating, modifying DOM nodes
* Most functions will take either a string or a DOM node reference, saving
  you the trouble of getElementById(s), $(s) or similar.


createDOM
=========

* Does a good job of turning any object into a DOM node
* Strings and numbers to text, flattens Arrays or iterators of anything
* Extensible with an adapter registry


createDOM example
=================

createDOM(tagName, attributes, contents...)

A simple list::

    var node = createDOM("ul", null,
        createDOM("li", null, "first"),
        createDOM("li", null, "second"));

Equivalent to::

    <ul><li>first</li><li>second</li></ul>


But that's still ugly...
========================

We use aliases instead, for all of the common tags::

    var node = UL(null,
        LI("first"),
        LI("second"));

Note that MochiKit 1.3 and later allows a text node as the first
parameter for convenience (saves a lot of "null" typing)


Flattening lists
================

Functional programming comes in handy for DOM creation::

    var items = ["first", "second"];
    var node = UL(null, map(LI, items));


What about attributes?
======================

First parameter is either an object (attributes), or a string (text node)::

    var classes = repeat({"class": "itemclass"});
    var items = ["first", "second"];
    var node = UL({"class": "listclass"},
        map(LI, classes, items));


Alternating classes
===================

More MochiKit.Iter goodies, good for table rows::

    var classes = cycle({"class": "even"}, {"class": "odd"});
    var items = ["first", "second"];
    var node = UL(null, map(LI, classes, items));


Scraping text
=============

Scraping text is useful for progressive enhancement...

HTML::

    <span id="scrape_me">text is <b>here</b></span>

JavaScript::

    >>> scrapeText("scrape_me");
    "text is here"


Reading forms
=============

HTML::

    <form id="formNode">
        <input type="hidden" name="foo" value="1" />
        <input type="hidden" name="bar" value="2" />
    </form>

JavaScript::

    >>> formContents("formNode")
    [["foo", "bar"], ["1", "2"]]


Manipulating DOM nodes
======================

appendChildNodes(parentNode, childNode...):
    Add nodes to parentNode using the DOM coercion rules from createDOM

replaceChildNodes(parentNode, childNode...):
    Remove all children from parentNode, then appendChildNodes

swapDOM(dest, src):
    Replace dest with src (if src is null, then dest is removed)


Manipulating DOM attributes
===========================

setNodeAttribute(node, attr, value):
    Set the node attribute attr=value 

updateNodeAttributes(node, attrs):
    Set the node attributes based on the object attrs
    

DOM Gotchas
===========

* DOM manipulation isn't as fast as innerHTML, but it's a LOT easier
* IE expects tables to have a TBODY


MochiKit.Color
==============

* Full CSS3 color model with alpha
* NSColor-like API (from Cocoa)
* Works in RGB, HSV, HSL
* Normalized, all components from [0.0, 1.0]


Creating colors from components
===============================

* Color.fromRGB(r, g, b, alpha=1.0)
* Color.fromHSL(h, s, l, alpha=1.0)
* Color.fromHSV(h, s, v, alpha=1.0)

Will also take objects, e.g. {r: 1, g: 0, b: 0, a: 1}


Creating colors from strings
============================

Color.fromString(str):
    Generally "does what you mean" with any valid CSS color description.
    "rgb(...)", "hsl(...)", "#RRGGBB", "blue"

Implementations in fromRGBString, fromHSLString, fromHexString, fromName.


Creating colors from DOM elements
=================================

- Color.fromBackground(node)
- Color.fromComputedStyle(node, style, css)
- Color.fromText(node)


Built-in NSColor colors
=======================

NSColor-based constructors for basic colors

- Color.whiteColor()
- Color.blueColor()
- Color.transparentColor()
- ...


Mixing colors
=============

- color.blendedColor(otherColor, fraction)
- color.colorWithHue(hue)
- color.colorWithLevel(level)
- color.colorWithSaturation(saturation)
- color.colorWithAlpha(alpha)


Getting color values
====================

Objects:

- color.asRGB()
- color.asHSL()
- color.asHSV()

Strings:

- color.toHexString()
- color.toRGBString()
- color.toHSLString()


MochiKit.Async
==============

* Yes, there is AJAX
* Generalized asynchronous model based on Twisted
* Handles XMLHttpRequest and timed events (setTimeout)


WTF is a Deferred?
==================

* A "promise" to call back exactly once with a single result (or error)
  at some time (could be immediately!)
* Can be chained
* Model works in any asynchronous platform with nearly any language
* Not "ideal" API, but without threads or anything resembling coroutines
  it's the best you can do.


Trivial Deferreds
=================

succeed(value):
    A successful deferred that will callback with value

fail(error):
    A failed deferred that will errback with value

maybeDeferred(func, arguments..):
    Call a function and make sure it returns a Deferred.  Non-deferred return
    values get wrapped with succeed, and errors get wrapped with fail.
    

Timed Events
============

wait(seconds, value):
    Return a Deferred that calls back with value after seconds have passed

callLater(seconds, func, arguments...):
    Return a Deferred that will call func(arguments) after seconds have passed


Network Events
==============

doSimpleXMLHttpRequest(url[, queryArguments]):
    Set up a GET XMLHttpRequest to url and return a Deferred.  The Deferred
    will callback with the XMLHttpRequest instance.

loadJSONDoc(url[, queryArguments]):
    Set up a simple XMLHttpRequest, process its responseText as JSON, and
    callback with the JSON object.


Deferred Usage
==============

Fetch a JSON document::

    function gotDocument(json) {
        // ...
    }
    var d = loadJSONDoc("example.json");
    d.addCallback(gotDocument);
    d.addErrback(logError);

Result Chaining
===============

The implementation of loadJSONDoc looks like this::

    var d = doSimpleXMLHttpRequest(url);
    d.addCallback(evalJSONDoc);
    return d;

Further callbacks get the result of evalJSONDoc, not the original
doSimpleXMLHttpRequest result.


Deferred Chaining
=================

Returning a Deferred from a callback will "pause" the callback chain::
    
    function gotDocument(json) {
        // ...
    }
    function delay(res) {
        return wait(2.0, res);
    }
    var d = loadJSONDoc("example.json");
    d.addCallback(delay);
    d.addCallback(gotDocument);
    d.addErrback(logError);
        

MochiKit.Signal
===============

* Crown jewel of MochiKit 1.3
* Sorry it took so long
* Browsers totally suck at events


What sucks about browser events?
================================

* IE is totally different
* IE's garbage "collector"
* Safari needs help
* They all disagree on pixel positions
* Damn near impossible to get key events to work properly cross-platform


connect to the DOM
==================

This works everywhere::

    function myClick(e) {
        var mouse = e.mouse();
        log("page coordinates: " + mouse.page);
        log("client coordinates: " + mouse.client);
    }
    connect("element_id", "onclick", myClick);


Not Really The Event Object
===========================

* MochiKit.Signal gives you a consistent event object, NOT the browser's.
* e.type() is the event type (doesn't include the "on" prefix)
* e.target() is the event target
* e.mouse() has consistent client and page coordinates
* e.key() has consistent keyboard state
* ... and consistent key codes and key names!!@#!
* e.stop() does both W3C stopPropagation and preventDefault for convenience


MochiKit on the Web
===================

Home page:
    http://mochikit.com/

Bug tracker/Wiki:
    http://trac.mochikit.com/

Subversion repository:
    http://svn.mochikit.com/


MochiKit Support
================

- Check the documentation
- Ask on the mailing list
- Check the wiki/bug tracker
- #mochikit on irc.freenode.net
