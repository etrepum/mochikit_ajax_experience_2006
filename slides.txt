.. include:: <s5defs.txt>

===================
 Intro to MochiKit
===================

:Authors: Bob Ippolito
:Date: May 2006

.. contents::
    :class: handout


What's MochiKit?
================

* Makes JavaScript suck less
* Provides browser workarounds
* Simplifies AJAX and DOM
* Plays nicely with other code


Another library?!
=================

* Prototype was undocumented, no tests, didn't play nice
* Dojo had no documentation or demos
* Everything else was outdated, not liberally licensed,
  not cross-platform


Why MochiKit?
=============

* Python-like (think "standard library")
* Abstracts async behavior
* MochiKit.DOM syntax makes DOM painless
* MochiKit.Signal works around LOTS of browser misfeatures (keyboard events!)
* Extremely well documented, tested, stable
* Safari 2, Firefox 1, IE 6, Opera 8


Why not MochiKit?
=================

* No support for IE 5.5
* No widgets
* No animation, transitions, etc.
* ... but we're working on a Scriptaculous port (MochiKit 1.4)


MochiKit.Base
=============

* Beats some sense into JavaScript
* Provides analogs to a lot Python built-ins and object protocols


toString ambiguity
==================

* Which one of these things is not like the other:

    - [1]
    - 1.0
    - "1"

* They're all the same according to JavaScript's toString!  Totally useless
  for debugging.


repr > toString
===============

* MochiKit provides repr() instead, just like Python.
  Think "programmer representation".

    - repr([1]) == "[1]"
    - repr(1.0) == "1"
    - repr("1") == "\"1\""

* repr understands primitive types, objects that implement ``repr`` or 
  ``__repr__``

* Extensible with an adapter registry


compare instead of operators
============================

* JavaScript comparisons are WHACK (these are ``true``!)

  - [1,"2"] == "1,2"
  - ([""] == "") && ([] == "") && ([] != [""])

* compare(a, b) provides consistent results

  - Usable with Array.prototype.sort
  - Understands String, Date, Array, Number, String, ...
  - Can be extended with adapter registry


JSON serialization
==================

* serializeJSON(object) -> JSON string

  - Understands primitive types
  - Will call ``json`` or ``__json__`` on objects if method exists
  - Can be extended with adapter registry


Wait.. Adapters?
================

* Not a good idea to hack on built-in objects
* MochiKit doesn't always know what you want to do
* Adapters let you extend existing functions

  - registerRepr(name, check, wrap, override=false)
  - registerComparator(name, check, wrap, override=false)
  - registerJSON(name, check, wrap, override=false)


Registering an adapter
======================

name:
    a unique identifier for your adapter (can be used to unregister)

check:
    a predicate, should wrap be called?

wrap:
    performs the operation


DOM comparator example
======================

Register HTML-based comparator for DOM nodes::

    function isDOMNode(node) {
        return typeof(node.nodeType) == "number";
    }

    function compareDOMNodes(a, b) {
        return compare(a.innerHTML, b.innerHTML);
    }

    registerComparator("compareDOM", isDOMNode, compareDOMNode);


queryString
===========

* queryString(["foo", "bar"], [1, 2]) == "foo=1&bar=2"
* queryString({foo: 1, bar: 2}) == "foo=1&bar=2"
* queryString("formNode") == "foo=1&bar=2", given::

    <form id="formNode">
        <input type="hidden" name="foo" value="1" />
        <input type="hidden" name="bar" value="2" />
    </form>


Mangling Objects
================

merge(obj[, ...]):
    Create a new object consisting of every property in the given objects
    (last object given takes precedence)

update(obj[, ...]):
    In-place version of merge

updatetree(obj[, ...]):
    Recursive version of update

setdefault(obj[, ...]):
    Like update, but does NOT overwrite existing properties


Object Introspection
====================

keys(obj):
    returns an Array of every property on obj

items(obj):
    returns an Array of every [property, value] on obj


Function functions
==================

bind(fn, self[, arg...]):
    new function, equivalent to fn.apply(self, concat(arg..., arguments))

itemgetter(name):
    new function(obj), equivalent to obj[name]

keyComparator(key, ...):
    new sort function that does compare(a[key], b[key])

forward(name):
    new function, forwards calls to this[name] (for delegation)


Basic Array functions
=====================

Array.prototype is missing lots of useful functions (cross-platform anyway)

concat(lst[, ...]):
    concatenates Arrays

extend(self, seq, skip=0):
    extends a list in-place


compare-based Array functions
=============================

find(lst, value, start=0, end=lst.length):
    finds index of value (using compare)

findIdentical(lst, value, start=0, end=lst.length):
    finds index of value (using === for identity)

listMin(lst):
    finds least item in lst (using compare)

listMax(lst):
    finds greatest item in lst (using compare)


Higher-order Array functions
============================

filter(predicate, lst):
    new Array where predicate(lst[n]) is true

map(func, lst):
    new Array of [func(lst[0]), func(lst[1]), ...]


MochiKit.Iter
=============

MochiKit.Iter provides generalized iteration, very similar to Python's
iteration protocol and itertools module.

* Works great on Arrays, but also on anything iterable.
* Anything with a ``next`` method is iterable, and the iteration stops when
  StopIteration is thrown.
* Objects can define an ``iter`` method to return an iterable
* Can register adapters too, with registerIterable.


Collapsing Iterators
====================

exhaust(iterable):
    Iterate over ``iterable`` and throw away the results

list(iterable):
    Convert ``iterable`` to a new Array

sorted(iterable[, cmp]):
    Return a sorted Array from ``iterable``, optionally using ``cmp`` for
    the comparator

sum(iterable, start=0):
    Return the sum of each item in ``iterable`` plus the ``start``.
    If ``iterable`` is empty, ``start`` will be returned.


Iterating Iterables
===================

The hard way::

    var itr = iter(iterable);
    try {
        while (true) {
            var item = itr.next();
            // ...
        }
    } catch (e) {
        if (e != StopIteration) {
            throw e;
        }
    }


Sane Iterable Iteration
=======================

The easy way::

    forEach(iterable, function (item) {
        // ...
    })


Infinite Iterators
==================

count(n=0):
    Iterates over a sequence of numbers (n, n + 1, n + 2, ...)

cycle(iterable):
    Iterates over iterable and saves the results.  Once iterable is exhausted,
    it iterates over the cached result Array indefinitely.

repeat(item):
    Returns an iterator that returns item over and over, same as
    cycle([item])


Should I care about Iter?
=========================

* You don't need to understand it to understand MochiKit
* Used primarily to simplify internal code, helps a lot with DOM generation
* You might not need it, but it is convenient for people used to a more
  functional paradigm
* If you don't use itertools in Python, you probably won't directly use
  much of MochiKit.Iter either


MochiKit.DateTime
=================

* JavaScript Date objects aren't very convenient
* W3C profile ISO 8601 style timestamps are Good

Dates
=====

isoDate(str):
    Convert ISO 8601 date to a Date object

toISODate(date):
    Convert a Date object to an ISO 8601 date

americanDate(str):
    Convert an MM/DD/YYYY date to a Date object

toAmericanDate(date):
    Convert a Date object to a M/D/YYYY date (1/1/2001)

toPaddedAmericanDate(date):
    Convert a Date object to a MM/DM/YYYY date (01/01/2001)


Time and Timestamps
===================

isoTimestamp(str):
    Convert a YYYY-MM-DD hh:mm:ss or YYYY-MM-DDThh:mm:ssZ timestamp to a
    Date object

toISOTime(date):
    Convert a Date object to a hh:mm:ss string

toISOTimestamp(date, realISO=false):
    Convert a Date object to a YYYY-MM-DD hh:mm:ss string.  If realISO is true,
    then use the proper YYYY-MM-DDThh:mm:ssZ form.


MochiKit.Format
===============

* JavaScript doesn't really do string formatting
* Users like to see big numbers with thousands separators
* Number formatting based on Java's Number Format Pattern Syntax


Simple String Mangling
======================

strip(str, chars="\\s"):
    Return a string based on str with leading and trailing whitespace stripped.
    If the chars regex is specified, it will be used instead of the default.

lstrip(str, chars="\\s"):
    strip only leading whitespace

rstrip(str, chars="\\s"):
    strip only trailing whitespace


Number Formatting
=================

numberFormatter(pattern, placeholder="", locale="default"):
    Return a function that formats numbers using the given pattern

Examples::
    
    >>> dollarFormat = numberFormatter("$###,###.##")
    >>> dollarFormat(1234567.89)
    "$1,234,567.89"
    
    >>> percentFormat = numberFormatter("###,###%")
    >>> percentFormat(123.45)
    "12,345%"


MochiKit.Logging
================

* alert() sucks
* Debugging is hard enough
* Not every browser has FireBug
* I've had no luck with Venkman
* Less luck with Microsoft's Script Debugger


Simple logging
==============

log(msg):
    Logs a message at the INFO level

logDebug(msg):
    Logs a message at the DEBUG level

logWarning, logError, logFatal...


Where'd my log messages go?
===========================

* In Safari, Firefox with FireBug, and Opera they will be logged to the
  appropriate console (but you can turn this off).
* Will also go to any logging listener
* Logging listeners are just functions that take log message objects


Bookmarklet Debugging
=====================

Just bookmark this::

    javascript:MochiKit.Logging.logger.debuggingBookmarklet()

Currently, this is a pop-up MochiKit.LoggingPane.


MochiKit.LoggingPane
====================

* A usable MochiKit.Logging listener
* Can be used in-line or as a pop-up window
* Could be fancier, but it gets the job done


Manually creating a LoggingPane
===============================

Pop-up::

    createLoggingPane()

Inline::

    createLoggingPane(true)


MochiKit.DOM
============

* DOM is painful, but it doesn't have to be
* Functions for finding, creating, modifying DOM nodes
* Most functions will take either a string or a DOM node reference, saving
  you the trouble of getElementById(s), $(s) or similar.


createDOM
=========

* Does a good job of turning any object into a DOM node
* Strings and numbers to text, flattens Arrays or iterators of anything
* Extensible with an adapter registry


createDOM example
=================

createDOM(tagName, attributes, contents...)

A simple list::

    var node = createDOM("ul", null,
        createDOM("li", null, "first item"),
        createDOM("li", null, "second item"));

Equivalent to::

    <ul>
        <li>first item</li>
        <li>second item</li>
    </ul>


But that's still ugly...
========================

We use aliases instead, for all of the common tags::

    var node = UL(null,
        LI("first item"),
        LI("second item"));

Note that MochiKit 1.3 and later allows a text node as the first
parameter for convenience (saves a lot of "null" typing)


Flattening lists
================

Functional programming comes in handy for DOM creation::

    var items = ["first item", "second item"];
    var node = UL(null, map(LI, items));


What about attributes?
======================

First parameter is either an object (attributes), or a string (text node)::

    var classes = repeat({"class": "myitemclass"});
    var items = ["first item", "second item"];
    var node = UL({"class": "mylistclass"},
        map(LI, classes, items));


Alternating classes
===================

More MochiKit.Iter goodies, good for table rows::

    var classes = cycle({"class": "even"}, {"class": "odd"});
    var items = ["first item", "second item"];
    var node = UL(null, map(LI, classes, items));


Scraping text
=============

Scraping text is useful for progressive enhancement...

HTML::

    <span id="scrape_me">text is <b>here</b></span>

JavaScript::

    >>> scrapeText("scrape_me");
    "text is here"


Reading forms
=============

HTML::

    <form id="formNode">
        <input type="hidden" name="foo" value="1" />
        <input type="hidden" name="bar" value="2" />
    </form>

JavaScript::

    >>> formContents("formNode")
    [["foo", "bar"], ["1", "2"]]


Manipulating DOM nodes
======================

appendChildNodes(parentNode, childNode...):
    Add nodes to parentNode using the DOM coercion rules from createDOM

replaceChildNodes(parentNode, childNode...):
    Remove all children from parentNode, then appendChildNodes

swapDOM(dest, src):
    Replace dest with src (if src is null, then dest is removed)


Manipulating DOM attributes
===========================

setNodeAttribute(node, attr, value):
    Set the node attribute attr=value 

updateNodeAttributes(node, attrs):
    Set the node attributes based on the object attrs
    
